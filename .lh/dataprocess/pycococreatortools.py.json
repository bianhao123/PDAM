{
    "sourceFile": "dataprocess/pycococreatortools.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1674820442863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1674820465563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,115 @@\n-x\n\\ No newline at end of file\n+#!/usr/bin/env python3\n+\n+import os\n+import re\n+import datetime\n+import numpy as np\n+from itertools import groupby\n+from skimage import measure\n+from PIL import Image\n+from pycocotools import mask\n+\n+convert = lambda text: int(text) if text.isdigit() else text.lower()\n+natrual_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ]\n+\n+def resize_binary_mask(array, new_size):\n+    image = Image.fromarray(array.astype(np.uint8)*255)\n+    image = image.resize(new_size)\n+    return np.asarray(image).astype(np.bool_)\n+\n+def close_contour(contour):\n+    if not np.array_equal(contour[0], contour[-1]):\n+        contour = np.vstack((contour, contour[0]))\n+    return contour\n+\n+def binary_mask_to_rle(binary_mask):\n+    rle = {'counts': [], 'size': list(binary_mask.shape)}\n+    counts = rle.get('counts')\n+    for i, (value, elements) in enumerate(groupby(binary_mask.ravel(order='F'))):\n+        if i == 0 and value == 1:\n+                counts.append(0)\n+        counts.append(len(list(elements)))\n+\n+    return rle\n+\n+def binary_mask_to_polygon(binary_mask, tolerance=0):\n+    \"\"\"Converts a binary mask to COCO polygon representation\n+\n+    Args:\n+        binary_mask: a 2D binary numpy array where '1's represent the object\n+        tolerance: Maximum distance from original points of polygon to approximated\n+            polygonal chain. If tolerance is 0, the original coordinate array is returned.\n+\n+    \"\"\"\n+    polygons = []\n+    # pad mask to close contours of shapes which start and end at an edge\n+    padded_binary_mask = np.pad(binary_mask, pad_width=1, mode='constant', constant_values=0)\n+    contours = measure.find_contours(padded_binary_mask, 0.5)\n+    contours = np.subtract(contours, 1)\n+    for contour in contours:\n+        contour = close_contour(contour)\n+        contour = measure.approximate_polygon(contour, tolerance)\n+        if len(contour) < 3:\n+            continue\n+        contour = np.flip(contour, axis=1)\n+        segmentation = contour.ravel().tolist()\n+        # after padding and subtracting 1 we may get -0.5 points in our segmentation \n+        segmentation = [0 if i < 0 else i for i in segmentation]\n+        polygons.append(segmentation)\n+\n+    return polygons\n+\n+def create_image_info(image_id, file_name, image_size, \n+                      date_captured=datetime.datetime.utcnow().isoformat(' '),\n+                      license_id=1, coco_url=\"\", flickr_url=\"\"):\n+\n+    image_info = {\n+            \"id\": image_id,\n+            \"file_name\": file_name,\n+            \"width\": image_size[0],\n+            \"height\": image_size[1],\n+            \"date_captured\": date_captured,\n+            \"license\": license_id,\n+            \"coco_url\": coco_url,\n+            \"flickr_url\": flickr_url\n+    }\n+\n+    return image_info\n+\n+def create_annotation_info(annotation_id, image_id, category_info, binary_mask, \n+                           image_size=None, tolerance=2, bounding_box=None):\n+\n+    if image_size is not None:\n+        binary_mask = resize_binary_mask(binary_mask, image_size)\n+\n+    binary_mask_encoded = mask.encode(np.asfortranarray(binary_mask.astype(np.uint8)))\n+\n+    area = mask.area(binary_mask_encoded)\n+    if area < 1:\n+        return None\n+\n+    if bounding_box is None:\n+        bounding_box = mask.toBbox(binary_mask_encoded)\n+\n+    if category_info[\"is_crowd\"]:\n+        is_crowd = 1\n+        segmentation = binary_mask_to_rle(binary_mask)\n+    else :\n+        is_crowd = 0\n+        segmentation = binary_mask_to_polygon(binary_mask, tolerance)\n+        if not segmentation:\n+            return None\n+\n+    annotation_info = {\n+        \"id\": annotation_id,\n+        \"image_id\": image_id,\n+        \"category_id\": category_info[\"id\"],\n+        \"iscrowd\": is_crowd,\n+        \"area\": area.tolist(),\n+        \"bbox\": bounding_box.tolist(),\n+        \"segmentation\": segmentation,\n+        \"width\": binary_mask.shape[1],\n+        \"height\": binary_mask.shape[0],\n+    } \n+\n+    return annotation_info\n\\ No newline at end of file\n"
                },
                {
                    "date": 1674820483524,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,31 +8,38 @@\n from skimage import measure\n from PIL import Image\n from pycocotools import mask\n \n-convert = lambda text: int(text) if text.isdigit() else text.lower()\n-natrual_key = lambda key: [ convert(c) for c in re.split('([0-9]+)', key) ]\n \n+def convert(text): return int(text) if text.isdigit() else text.lower()\n+\n+\n+def natrual_key(key): return [convert(c) for c in re.split('([0-9]+)', key)]\n+\n+\n def resize_binary_mask(array, new_size):\n-    image = Image.fromarray(array.astype(np.uint8)*255)\n+    image = Image.fromarray(array.astype(np.uint8) * 255)\n     image = image.resize(new_size)\n     return np.asarray(image).astype(np.bool_)\n \n+\n def close_contour(contour):\n     if not np.array_equal(contour[0], contour[-1]):\n         contour = np.vstack((contour, contour[0]))\n     return contour\n \n+\n def binary_mask_to_rle(binary_mask):\n     rle = {'counts': [], 'size': list(binary_mask.shape)}\n     counts = rle.get('counts')\n     for i, (value, elements) in enumerate(groupby(binary_mask.ravel(order='F'))):\n         if i == 0 and value == 1:\n-                counts.append(0)\n+            counts.append(0)\n         counts.append(len(list(elements)))\n \n     return rle\n \n+\n def binary_mask_to_polygon(binary_mask, tolerance=0):\n     \"\"\"Converts a binary mask to COCO polygon representation\n \n     Args:\n@@ -42,9 +49,10 @@\n \n     \"\"\"\n     polygons = []\n     # pad mask to close contours of shapes which start and end at an edge\n-    padded_binary_mask = np.pad(binary_mask, pad_width=1, mode='constant', constant_values=0)\n+    padded_binary_mask = np.pad(\n+        binary_mask, pad_width=1, mode='constant', constant_values=0)\n     contours = measure.find_contours(padded_binary_mask, 0.5)\n     contours = np.subtract(contours, 1)\n     for contour in contours:\n         contour = close_contour(contour)\n@@ -52,38 +60,41 @@\n         if len(contour) < 3:\n             continue\n         contour = np.flip(contour, axis=1)\n         segmentation = contour.ravel().tolist()\n-        # after padding and subtracting 1 we may get -0.5 points in our segmentation \n+        # after padding and subtracting 1 we may get -0.5 points in our segmentation\n         segmentation = [0 if i < 0 else i for i in segmentation]\n         polygons.append(segmentation)\n \n     return polygons\n \n-def create_image_info(image_id, file_name, image_size, \n+\n+def create_image_info(image_id, file_name, image_size,\n                       date_captured=datetime.datetime.utcnow().isoformat(' '),\n                       license_id=1, coco_url=\"\", flickr_url=\"\"):\n \n     image_info = {\n-            \"id\": image_id,\n-            \"file_name\": file_name,\n-            \"width\": image_size[0],\n-            \"height\": image_size[1],\n-            \"date_captured\": date_captured,\n-            \"license\": license_id,\n-            \"coco_url\": coco_url,\n-            \"flickr_url\": flickr_url\n+        \"id\": image_id,\n+        \"file_name\": file_name,\n+        \"width\": image_size[0],\n+        \"height\": image_size[1],\n+        \"date_captured\": date_captured,\n+        \"license\": license_id,\n+        \"coco_url\": coco_url,\n+        \"flickr_url\": flickr_url\n     }\n \n     return image_info\n \n-def create_annotation_info(annotation_id, image_id, category_info, binary_mask, \n+\n+def create_annotation_info(annotation_id, image_id, category_info, binary_mask,\n                            image_size=None, tolerance=2, bounding_box=None):\n \n     if image_size is not None:\n         binary_mask = resize_binary_mask(binary_mask, image_size)\n \n-    binary_mask_encoded = mask.encode(np.asfortranarray(binary_mask.astype(np.uint8)))\n+    binary_mask_encoded = mask.encode(\n+        np.asfortranarray(binary_mask.astype(np.uint8)))\n \n     area = mask.area(binary_mask_encoded)\n     if area < 1:\n         return None\n@@ -93,9 +104,9 @@\n \n     if category_info[\"is_crowd\"]:\n         is_crowd = 1\n         segmentation = binary_mask_to_rle(binary_mask)\n-    else :\n+    else:\n         is_crowd = 0\n         segmentation = binary_mask_to_polygon(binary_mask, tolerance)\n         if not segmentation:\n             return None\n@@ -109,7 +120,7 @@\n         \"bbox\": bounding_box.tolist(),\n         \"segmentation\": segmentation,\n         \"width\": binary_mask.shape[1],\n         \"height\": binary_mask.shape[0],\n-    } \n+    }\n \n\\ No newline at end of file\n-    return annotation_info\n+    return annotation_info\n"
                },
                {
                    "date": 1674827034796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,5 +122,45 @@\n         \"width\": binary_mask.shape[1],\n         \"height\": binary_mask.shape[0],\n     }\n \n-    return annotation_info\n\\ No newline at end of file\n+    return annotation_info\n+\n+\n+def create_annotation_with_bbox_info(annotation_id, image_id, category_info, binary_mask,\n+                                     image_size=None, tolerance=2, bounding_box=None):\n+\n+    if image_size is not None:\n+        binary_mask = resize_binary_mask(binary_mask, image_size)\n+\n+    binary_mask_encoded = mask.encode(\n+        np.asfortranarray(binary_mask.astype(np.uint8)))\n+\n+    area = mask.area(binary_mask_encoded)\n+    if area < 1:\n+        return None\n+\n+    if bounding_box is None:\n+        bounding_box = mask.toBbox(binary_mask_encoded)\n+\n+    if category_info[\"is_crowd\"]:\n+        is_crowd = 1\n+        segmentation = binary_mask_to_rle(binary_mask)\n+    else:\n+        is_crowd = 0\n+        segmentation = binary_mask_to_polygon(binary_mask, tolerance)\n+        if not segmentation:\n+            return None\n+\n+    annotation_info = {\n+        \"id\": annotation_id,\n+        \"image_id\": image_id,\n+        \"category_id\": category_info[\"id\"],\n+        \"iscrowd\": is_crowd,\n+        \"area\": area.tolist(),\n+        \"bbox\": bounding_box.tolist(),\n+        \"segmentation\": segmentation,\n+        \"width\": binary_mask.shape[1],\n+        \"height\": binary_mask.shape[0],\n+    }\n+\n+    return annotation_info\n"
                }
            ],
            "date": 1674820442863,
            "name": "Commit-0",
            "content": "x"
        }
    ]
}